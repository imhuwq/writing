---
title: 关于 AI 程序加密的一些总结
date: 2023-10-21 00:11:00
categories:
- 技术
tags:
- c++
- python
- 程序加密
---

现在正是 AI 技术火热的时候，AI 技术商用时的两个需求也越来越凸显：
- 技术方：保护技术知识产权
- 应用方：保护数据安全隐私

把 AI 程序加密后私有化部署到应用方，是一个可以在某种程度上二者兼得的方案(尤其在早期 AI 技术方没有太多话语权的时候)。
由于大部分 AI 程序都建于 Python 生态之上，因此很多时候，AI 程序的加密，其实就是 Python 程序的加密。

Python AI 程序，一般至少包含 AI 模型、推理逻辑以及其它逻辑。  
在加密的 Python AI 程序中，这三个方面都必须加密，才能完整地保护技术方的知识产权。
下面细述。

## 1. 最核心：模型加密
模型就是 AI 程序的核心。  
模型不加密，那整个 AI 程序也没有多少必要去加密。
现在有不少对模型进行加密的方法，无非就是使用对称加密算法或者非对称加密算法，对模型的二进制文件加密后再进行分发。在进行推理前，先使用**密钥**解密模型，再进行推理。 

好处是，第三方拿到模型文件后，不能直接用，必须先解密。  
不足是，保护模型的工作，转移到了“保护模型解密程序”的环节上。   

如果把模型用最先进的技术加密，但是用明文的方式写上了解密步骤，就和“**把钱存到银行，但是把密码写到银行卡背面**”是一样的。  

## 2. 不可缺：程序加密
程序加密是一个复杂的工程，这点游戏行业深有体会。  
Python 程序的脚本语言特征更提高了这个难度：明文编写，运行时依赖 Python 编译器。  

所以对 Python AI 程序加密的方案，又分为几个方向。  
从保护程度、实现成本角度考虑，每种方案各有利弊。
下面详细分析，并给出各种方案的评级。

### 2.0 各种评价的指标
1. 实现成本
指技术方需要投入的成本。
✨：有成熟的方案可以实现，基本不再需要额外处理
✨✨：有成熟的方案，需要额外处理一些适配性问题
✨✨✨：有方案，需要对代码做一些局部重构乃至重写
✨✨✨✨：有方案，需要做非常多的代码重构乃至重写
✨✨✨✨✨：有思路，理论上可行，需要投入非常多的资源进行底层定制

2. 保护力度
指保护程序里的代码逻辑及技术思想不被人窃取，以及保护运行时程序不被非法调用/绕过。

✨：降低了源代码的可读性，但还是 Python 代码或者字节码
✨✨：不可逆为 Python 代码，能被逆向分析汇编指令，能被非法调用
✨✨✨：不可逆为 Python 代码，不能被逆向分析汇编指令，能被非法调用
✨✨✨✨：不可逆为 Python 代码，能被逆向分析汇编指令，很难被非法调用
✨✨✨✨✨：不可逆为 Python 代码，不能被逆向分析汇编指令，很难被非法调用

注意，以上说辞中的“不能”，都只是“几乎不能，很难”的意思。
理论上没有程序不能被破解，不然防盗版、反外挂也不会一直如此挣扎。  

下面继续分析私有化部署的场景下，软件层面加密的各种方案得失。

### 2.1 使用代码混淆
基本只是文本上的混淆，输出的仍是 Python 代码，保护程度相当少。  
唯一的优势是实现简单。
成本：✨
保护：✨

### 2.2 使用 PyArmor 加密 Python 代码
Pyarmor 的基本原理是把 Python 代码混淆后加密为不可逆的二进制数据，在调用时解密这些二进制再交给 Python 去运行，运行完后从内存立即删除解密后的数据。  

这种方案下，编译后的 Python 代码几乎不可能进行分析，但是在运行时仍然依赖 Python 、PyArmor 和其它系统库，且有一定性能损耗，不能防止非法调用。
成本: ✨✨
保护: ✨✨✨

### 2.3 编译 Python 为二进制 `so`
`so` 的逆向虽然有可能，但是成本也比较高，还有一些额外措施可以提高逆向难度：
- 去除 `so` 中的所有符号：`strip -s $file.so`  
- 减少常量字符串的使用，尤其是全局常量字符串

不过，这种方案同样不能防止非法调用。
成本：✨✨
保护：✨✨

### 2.4 使用 C/C++ 重写关键逻辑
上面的两种方案能在某种程度上保护 Python 代码，但是不能防止非法调用。

当代码中使用了第三方库来做一些加密/解密操作的时候，Hacker 可以预先 Hook 这些模块，捕获输入和输出，从而知道你的输入和输出。如果依赖的是 Python 的库，那这样的拦截更简单。

比如程序里面依赖了 Python 的 md5 功能做一致性校验，下面这段代码就能让大部分基于 md5 的校验都通过，因为不管输入是啥，输出的 md5 都是一样的：

```python
def hack_md5():
	import hashlib
	o_md5 = hashlib.md5
	
	def n_md5(*args, **kwargs):
		print("calling Hacked md5!")
		return o_md5("Hacked md5".encode("utf-8"))

	hashlib.md5 = n_md5

hack_md5()
```

所以对于一些关键算法，要避免使用第三方库，而是自己用 C++ 实现。
同样也有一些额外措施可以提高逆向难度：
- 去除 `so` 中的所有符号：`strip -s $file.so`  
- 减少常量字符串的使用，尤其是全局常量字符串
- 减少关键路径中的 log，提高 Hacker 的调试成本
- 提高关键路径中的判断复杂度
	- 避免一次变量判断就通过所有检测

成本：✨✨✨✨
保护：✨✨✨✨

### 2.5 定制化 Python 编译器
还有一种理论上可行的方案，就是深度定制化 Python Interpreter。  
主要是做这么几件事情：
- 创建一对非对称密钥
- Hack Python Interpreter
	- 内置上述密钥中的公钥
	- Import 文件时只能 Import 使用公钥解密的数据
	- 停止落地 pyc 到文件的行为，并从内存中删除 pyc 
- 代码部署时用私钥加密
	- 把安装到的第三方依赖包全部加密
	- 通过 Docker 镜像的方式进行分发

这种程度的保护，和 PyArmor 类似，但是也把 Python Interpreter 和依赖的第三方 Python 库也保护起来了。当然，都定制化 Python Interpreter 了，那再定制化一些核心加密/解密库也是顺手的事。
成本: ✨✨✨✨✨
保护: ✨✨✨✨

### 2.6 综合 Cython 和 PyArmor
对于少数入口函数代码，使用 PyArmor 加密为不可逆、不可分析汇编指令的代码(✨✨✨保护)。对于大部分代码，可以使用 Cython 编译为不可逆、可以分析汇编指令的 `so` 文件(✨✨保护)。二者的成本都是二星 ✨✨ 。

这比使用 PyArmor 加密全部代码的好处是，绝大部分运行时都可以摆脱对 Python Interpreter 的依赖。并且可以用 C++ 独立实现核心库，进一步摆脱系统级别的依赖。这可以防止非法调用。
但同时，它也利用了 PyArmor 加密的代码完全不可逆的优势，把少数入口函数保护起来。

以模型加密的场景举例：
- 创建一对非对称密钥
- 使用私钥加密模型
- 把公钥用 PyArmor 加密到模型解密的入口函数中
	- 如果把公钥全部编译到 `so` 里面去，没有从理论上杜绝逆向的可能性
- 入口函数中调用独立用 C/C++ 实现的定制化解密模块
	- 如果不用 C/C++ 独立实现解密模块而是
		- 用 Python 的，Hacker 可以非常快速拦截 Python 库做输入和输出分析
		- 用系统的 `so`，Hacker 也可以拦截这些系统调用再做分析，系统库一般有成熟的工具和方法
	- 用自己实现的，Hacker 至少要先逆向我们的 `so` ，难度更高(✨✨✨✨)
	- 最好分步骤、分阶段调用 `so` 解密，避免 `so` 中提供一个统一接口解密模型

不独立实现核心库的情况下：
成本：✨✨
保护：✨✨(全局) + ✨✨✨(入口)

使用 C/C++ 独立实现核心库的情况下：
成本：✨✨✨✨
保护：✨✨✨✨(全局) + ✨✨✨✨✨(入口)

## 3. 哪种方案
上面分析了 6 种方案，并且给出了对应评级。  
不过，再重申一遍，理论上没有程序不能被破解。另外这些评级也只是参考值。

基于此再来做选择的话，**2.6 综合 Cython 和 PyArmor** 是比较合适的方案。
 - 在项目前期的时候，二星到三星程度的保护已经够了。
 - 随着项目发展，可以再逐步投入成本实现更高级别的保护。
