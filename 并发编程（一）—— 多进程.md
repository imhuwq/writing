---
title: 并发编程（一）—— 多进程
date: 2019-04-08 21:06:22
categories:
- 技术
tags:
- 计算机系统
- 并发编程
---

之前在[《基于异常控制流的进程协作》](https://imhuwq.com/2019/03/28/%E5%9F%BA%E4%BA%8E%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%8D%8F%E4%BD%9C/)一文中我们从操作系统和硬件的角度简单分析了单核 CPU 上多进程的并发和协作的**实现机制**。这次我们换个角度，从**使用方式**的角度来分析并发编程。  
<!--more-->

## 一、为什么要使用多进程并发
我们先想想，为什么需要多进程并发？  
- 多任务机制。一个程序不可能实现所有的任务，所以计算机上必然要运行多个程序。如果选择串行模式的话，一个进程只能在等待另一个进程结束后才能执行，很多功能将无法实现。比如在打开文件浏览器程序浏览文件时，就不能开始执行 word 处理程序
- 加快任务处理的速度。一个 CPU 在一个时刻内只能执行一个进程的指令，反之亦然，一个进程在一个时刻内只能享有一个 CPU 资源。如果计算机硬件上有多个 CPU ，我们就能利用多个进程来使用多个 CPU 的资源

既然有多进程的需求，那就有多进程协作的需求。进程和进程之间如何协作呢？  
什么样算是协作？协作就是一个进程告诉另一个进程发生了什么事，然后另一个进程决定如何反应。  
这其实就是两件事：怎么沟通信息和如何处理信息。  

## 二、多进程并发如何沟通信息
如何沟通信息呢？程序无非就是“输入-处理-输出”的流程，所谓接受信息和发送信息，其实就是在接受输入和产生输出，只不过输入的来源是其它进程的输出，输出的去向是其它进程的输入。但是进程又偏偏给每个程序一个独自享有整个计算机资源的假象，每个进程是感知不到其它进程的，于是对每个进程而言，“其它”进程的输入和输出就成了无稽之谈。  
不过，我们其实还是有机会的。想想看，输入和输出都是保存在内存中的，进程不一定要明确地把信息发送到其它某一个进程中去，只需要多个进程能够**共享读写同样地内存区域**就行了。  
怎么样创建共享的内存区域呢？  

### 2.1 共享内核内存空间
内核空间中最上面的两个页大小的空间是每个进程私有的空间，暂且称为 2P 。虽然 2P 是私有的，但是当其它进程处于内核模式下时，是有读写任意地址的权限的，其中自然包括 2P。而恰好在 2P 空间的最下面保存着进程的 `task_struct`，`task_struct` 又保存着进程的信号位向量。当进程在内核模式下读写这个区域时，就能实现向进程发送**信号**或者接受信号的功能。  
在内核空间的最下面保存着内核代码和数据，暂且把这段区域称为 KN，KN 对所有进程来说都是共享读的。把除去 2P 和 KN 后剩下的区域称为 PP，操作系统提供了 **PIPE** 和 **FIFO** 两种机制来在 PP 中创建共享读写的 Buffer。PIPE 和 FIFO 都被设计成一个 first-in-first-out 的队列，PIPE 只是一个内存 Buffer，而 FIFO 虽然也是一个内存 Buffer，但是被设计为一个文件类型，可以像文件一样打开和读写。除了 PIPE 和 FIFO 外，还有 **Message Queue**(消息队列)这一种机制。Message Queue 和前两种的实现思路是差不多的，都是基于内核空间内存的先进先出队列，只不过 Message Queue 中传递的数据不再是字节(byte)，而是一个特定类型的数据(byte package, message)。  

### 2.2 共享用户内存空间
使用 **`mmap`** 可以把文件映射到内存区域中，并且可以指定映射方式为共享的。如果两个进程对同一个文件使用共享的映射方式的话，两个进程就共享了这些内存区域。`mmap` 可以映射一个真实的磁盘文件，也可以映射一个匿名文件。匿名文件和 FIFO 一样也是一个内存中文件，不过它处于用户空间，而 FIFO 处于内核空间。除了匿名文件，还有一个基于用户内存空间的文件系统，叫 **`shm`** 文件系统。基于 `shm` 文件系统有 System V 共享内存机制。  

### 2.3 共享“共享内存在哪”的信息
怎么样告知其它进程一段内存区域是共享的呢？ 
`task_struct` 中的信号由操作系统内核在内核模式中自动读和写，所以不用担心。  
FIFO、mmap 非匿名文件、shm 都使用到了具体的文件路径/ID，所以多进程中可以通过相同的文件名来获取共享内存区，也可以通过 `fork` 和 `execve` 继承的文件描述符表来获取共享内存区域。  
通过 PIPE、mmap 匿名文件和 Message Queue 创建的共享内存区域，只有通过这些函数调用的返回值)(指针或者文件描述符)才能获取到，而这些返回值保存在进程的虚拟内存空间中，只有通过 `fork` 和 `execv` 复制父进程的虚拟内存空间才能获取到。  

## 三、多进程并发如何处理信息
### 3.1 如何发送和接受消息
程序可以用 `kill` 系统调用向指定进程发送信号，但是并没有接受信号的系统调用，因为发送信号和接受信号是同时发生的(此处接受信号并不等于处理信号)；PIPE 和 FIFO 队列使用 `read` 和 `write` 系统调用来接受和发送信息，Message Queue 使用 `msgsnd` 和 `msgrcv` 系统调用来发送和接受消息；mmap 和 shm 直接使用指针地址读写。  

### 3.2 如何处理消息
发送消息总是即时的，但是接受新消息却需要程序主动去检查或者被通知才能知道。在接受到新消息前，程序是**异步**地执行其它指令，还是**阻塞**着直到新消息到来呢？  
信号处理机制总是异步的，除非通过 `waitpid` 显示地阻塞当前进程并等待子进程的 `SICHLD` 信号。进程从内核模式切换到用户模式之际，会自动检查接受到地信号并进行处理。而这样地时机，一般发生在进程刚刚被调入 CPU 开始执行时，或着进程刚刚完成一次系统调用并返回时。程序可以用 `signal` 来为信号注册优先的处理函数，如果没有注册，则调用默认的信号处理程序。    
三种队列总是阻塞的，当队列满时会阻塞写，当队列空时会阻塞读。  
使用 mmap 或者 shm 的话，就没有操作系统提供的异步或者阻塞机制，只能由程序自己来实现。  

## 四、多进程协作 API
### 4.1 fork 和 execve

### 4.2 信号机制

### 4.3 三种队列

### 4.4 mmap 和 shm

### 4.5 waitpid

## 五、总结
