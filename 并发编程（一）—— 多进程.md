---
title: 并发编程（一）—— 多进程
date: 2019-04-08 21:06:22
categories:
- 技术
tags:
- 计算机系统
- 并发编程
---

之前在[《基于异常控制流的进程协作》](https://imhuwq.com/2019/03/28/%E5%9F%BA%E4%BA%8E%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%8D%8F%E4%BD%9C/)一文中我们从操作系统和硬件的角度简单分析了单核 CPU 上多进程的并发和协作的**实现机制**。这次我们换个角度，从**使用方式**的角度来分析并发编程。  
<!--more-->

## 一、为什么要使用多进程并发
我们先想想，为什么需要多进程并发？  
- 多任务机制。一个程序不可能实现所有的任务，所以计算机上必然要运行多个程序。如果选择串行模式的话，一个进程只能在等待另一个进程结束后才能执行，很多功能将无法实现。比如在打开文件浏览器程序浏览文件时，就不能开始执行 word 处理程序
- 加快任务处理的速度。一个 CPU 在一个时刻内只能执行一个进程的指令，反之亦然，一个进程在一个时刻内只能享有一个 CPU 资源。如果计算机硬件上有多个 CPU ，我们就能利用多个进程来使用多个 CPU 的资源

既然有多进程的需求，那就有多进程协作的需求。进程和进程之间如何协作呢？  
什么样算是协作？协作就是一个进程告诉另一个进程发生了什么事，然后另一个进程决定如何反应。  
这其实就是两件事：怎么沟通信息和如何处理信息。  

## 二、多进程并发如何沟通信息
如何沟通信息呢？程序无非就是“输入-处理-输出”的流程，所谓接受信息和发送信息，其实就是在接受输入和产生输出，只不过输入的来源是其它进程的输出，输出的去向是其它进程的输入。但是进程又偏偏给每个程序一个独自享有整个计算机资源的假象，每个进程是感知不到其它进程的，于是对每个进程而言，“其它”进程的输入和输出就成了无稽之谈。  
不过，我们其实还是有机会的。想想看，输入和输出都是保存在内存中的，进程不一定要明确地把信息发送到其它某一个进程中去，只需要多个进程能够**共享读写同样地内存区域**就行了。  
怎么样创建共享的内存区域呢？  

### 2.1 共享内核内存空间
内核空间中最上面的两个页大小的空间是每个进程私有的空间，暂且称为 2P 。虽然 2P 是私有的，但是当其它进程处于内核模式下时，是有读写任意地址的权限的，其中自然包括 2P。而恰好在 2P 空间的最下面保存着进程的 `task_struct`，`task_struct` 又保存着进程的信号位向量。当进程在内核模式下读写这个区域时，就能实现向进程发送**信号**或者接受信号的功能。  
在内核空间的最下面保存着内核代码和数据，暂且把这段区域称为 KN，KN 对所有进程来说都是共享读的。把除去 2P 和 KN 后剩下的区域称为 PP，操作系统提供了 **PIPE** 和 **FIFO** 两种机制来在 PP 中创建共享读写的 Buffer。PIPE 和 FIFO 都被设计成一个 first-in-first-out 的队列，PIPE 只是一个内存 Buffer，而 FIFO 虽然也是一个内存 Buffer，但是被设计为一个文件类型，可以像文件一样打开和读写。除了 PIPE 和 FIFO 外，还有 **Message Queue**(消息队列)这一种机制。Message Queue 和前两种的实现思路是差不多的，都是基于内核空间内存的先进先出队列，只不过 Message Queue 中传递的数据不再是字节(byte)，而是一个特定类型的数据(byte package, message)。  

### 2.2 共享用户内存空间
使用 **`mmap`** 可以把文件映射到内存区域中，并且可以指定映射方式为共享的。如果两个进程对同一个文件使用共享的映射方式的话，两个进程就共享了这些内存区域。`mmap` 可以映射一个真实的磁盘文件，也可以映射一个匿名文件。匿名文件和 FIFO 一样也是一个内存中文件，不过它处于用户空间，而 FIFO 处于内核空间。除了匿名文件，还有一个基于用户内存空间的文件系统，叫 **`shm`** 文件系统。基于 `shm` 文件系统有 System V 共享内存机制。  

### 2.3 共享“共享内存在哪”的信息
怎么样告知其它进程一段内存区域是共享的呢？ 
`task_struct` 中的信号由操作系统内核在内核模式中自动读和写，所以不用担心。  
FIFO、mmap 非匿名文件、shm 都使用到了具体的文件路径/ID，所以多进程中可以通过相同的文件名来获取共享内存区，也可以通过 `fork` 和 `exec` 继承的文件描述符表来获取共享内存区域。  
通过 PIPE、mmap 匿名文件和 Message Queue 创建的共享内存区域，只有通过这些函数调用的返回值)(指针或者文件描述符)才能获取到，而这些返回值保存在进程的虚拟内存空间中，只有通过 `fork` 和 `exec` 复制父进程的虚拟内存空间才能获取到。  

## 三、多进程并发如何处理信息
### 3.1 如何发送和接受消息
程序可以用 `kill` 系统调用向指定进程发送信号，但是并没有接受信号的系统调用，因为发送信号和接受信号是同时发生的(此处接受信号并不等于处理信号)；PIPE 和 FIFO 队列使用 `read` 和 `write` 系统调用来接受和发送信息，Message Queue 使用 `msgsnd` 和 `msgrcv` 系统调用来发送和接受消息；mmap 和 shm 直接使用指针地址读写。  

### 3.2 如何处理消息
发送消息总是即时的，但是接受新消息却需要程序主动去检查或者被通知才能知道。在接受到新消息前，程序是**异步**地执行其它指令，还是**阻塞**着直到新消息到来呢？  
信号处理机制总是异步的，除非通过 `waitpid` 显示地阻塞当前进程并等待子进程的 `SICHLD` 信号。进程从内核模式切换到用户模式之际，会自动检查接受到地信号并进行处理。而这样地时机，一般发生在进程刚刚被调入 CPU 开始执行时，或着进程刚刚完成一次系统调用并返回时。程序可以用 `signal` 来为信号注册优先的处理函数，如果没有注册，则调用默认的信号处理程序。    
三种队列总是阻塞的，当队列满时会阻塞写，当队列空时会阻塞读。  
使用 mmap 或者 shm 的话，就没有操作系统提供的异步或者阻塞机制，只能由程序自己来实现。  

## 四、多进程协作 API
### 4.1 fork 和 exec
多进程协作的前提是创建进程。  
`fork` 用来从当前进程分叉出一个子进程，然后返回两次，在父进程中返回子进程的 pid，在子进程中返回 0。子进程复制了父进程的页表和 vma，子进程和父进程所有非共享 vma 被设置为私有的写时复制的，其中的页都被设置为只读的。当两个进程中任何一个尝试进行页面写操作时，会触发页错误从而进行写时复制。除了页表和 vma 外，子进程还复制了父进程的文件描述符表：  
```c
/* fork_example.c
 * 正如上述程序所展示的那样，`fork` 返回了两次。
 * 两个进程共享了内存(`g`)，但是修改内存时触发了写时复制(`l`)。
 * 子进程复制了父进程的文件描述符表，所以它们的 `printf` 输出到同一个 `STDOUT`。  
 */

#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int g = 5;

int main() {
    int l = 3;

    pid_t pid = fork();
    if (pid == 0) {
        l += 1;
        printf("child process: pid=%d, g=%d, l=%d\n", pid, g, l);
    } else {
        printf("parent process: pid=%d, g=%d, l=%d\n", pid, g, l);
    }
}

/* output:
 * parent process: pid=696, g=5, l=3
 * child process: pid=0, g=5, l=4
 */
```

接下来看一个 `exec` 的示例：  
```c
/* exec_example.c
 * 在子进程中使用 `exec` 把子进程替换为 `/bin/ls` 程序，替换成功后，子进程就不再执行了。
 * 但是因为 `exec` 不会删除文件描述符表，所以其 STDOUT 和父进程还是同一个。  
 */
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <cstring>

int g = 5;

int main() {
    int l = 3;

    pid_t pid = fork();
    if (pid == 0) {
        l += 1;
        printf("child process: pid=%d, g=%d, l=%d\n", pid, g, l);

        char * argv_list[] = {"/bin/ls","/",NULL};
        int ok = execv("/bin/ls", argv_list);

        if (ok == -1) {
            printf("failed to replace process: %s\n", strerror(errno));
        }
        printf("child process: pid=%d, g=%d, l=%d\n", pid, g, l);
    } else {
        printf("parent process: pid=%d, g=%d, l=%d\n", pid, g, l);
        sleep(3);
    }
}

/*
 * parent process: pid=2160, g=5, l=3
 * child process: pid=0, g=5, l=4
 * bin   dev  home  lib	lib64  mnt  proc  run	snap  sys  usr
 * boot  etc  init  lib32	media  opt  root  sbin	srv   tmp  var
 */
```  

### 4.2 信号机制
程序使用 `signal` 来注册信号处理函数，使用 `kill` 来向其它进程发送信号。
使用 `signal` 注册的信号处理函数，在被调用时会阻塞其它信号。在有些平台上，信号处理函数执行完成时需要程序来重新注册，在此之前接受到的信号可能会采取默认处理程序。如果想要更大的控制力度，可以使用 `sigaction` 函数，但是它用起来也更困难。  
`kill` 函数的第一个参数为 pid，pid 如何发挥作用，在 linux 文档里面有详细说明，这里就不赘述了。  
需要注意的是，信号处理有可能打断挂起的系统调用，系统调用被打断后可能不再继续执行，而是返回 ERINT 错误。信号处理函数自己也有可能被其它信号处理函数打断，但是被打断后会继续执行。
```c
/*
 * signal_example.c
 * 程序被打断后，触发 `SIGINT` 处理函数，在其中又使用 `kill` 系统调用向自己发送了 `SIGABRT` 信号。
 * 从 `kill` 系统调用返回后，内核检查发现接受到了 `SIGABRT` 信号，于是先去执行 `SIGABRT` 的处理函数。
 * 直到 `SIGABRT` 处理函数返回后且没有检查到新的信号，才继续执行 `SIGINT` 处理函数。  
 * 可以发现，信号处理函数和程序的主逻辑以及其它信号处理函数是并发执行的。  
 */
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#include <sys/types.h>
#include <zconf.h>

int s1 = 0;
int s2 = 0;
int pid = 0;

void sig_user1_handler(int) {
    kill(pid, SIGABRT);
    s1 = 1;
    exit(s1 + s2);
}

void sig_user2_handler(int) {
    s2 = 2;
}

int main() {
    signal(SIGINT, sig_user1_handler);
    signal(SIGABRT, sig_user2_handler);
    pid = getpid();

    while (true) {}
}

/*
 * ^C
 * Process finished with exit code 3
 */
```

### 4.3 三种队列
接下来分别说明 PIPE、FIFO 和 Message Queue 三种先进先出队列。  
```c
/*
 * pipe_example.c
 * pipe 在内核中创建了一个 buffer 并返回两个文件描述符，一个用来读， 一个用来写
 * 文件描述符只能在父子进程之间共享，所以 PIPE 只能用于父子进程之间
 * pipe 默认是堵塞的，使用 read 和 write 系统调用来以字节为单位进行读写
 */

#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

int main() {
    int r_w[2];
    if (pipe(r_w) == -1) {
        printf("failed to open pipe: %s\n", strerror(errno));
        exit(1);
    }

    int read_fd = r_w[0];
    int write_fd = r_w[1];
    pid_t pid = fork();

    if (pid == 0) {
        char buf[10];
        if (read(read_fd, buf, 10) == -1) {
            printf("failed to read pipe: %s\n", strerror(errno));
            exit(1);
        }
        printf("%s\n", buf);
    } else {
        char buf[10] = "12345abcd";
        if (write(write_fd, buf, 10) == -1) {
            printf("failed to write pipe: %s\n", strerror(errno));
            exit(1);
        }
        sleep(1);
    }
}
```

接下来看看 `FIFO`。
```c
/*
 * fifo_write_example.c
 * 使用路径 “/tmp/testfifo” 创建或者打开一个 FIFO 文件
 */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <sys/stat.h>
#include<fcntl.h>

int main() {
    int pid = getpid();
    int fd = mkfifo("/tmp/testfifo", S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
    if (fd < 0 && errno == EEXIST) {
        fd = open("/tmp/testfifo", O_RDWR);
    }
    if (fd < 0) {
        printf("failed to create fifo: %s\n", strerror(errno));
        exit(1);
    }

    char msg[6];
    sprintf(msg, "%s", "hello");
    while (true) {
        write(fd, msg, 6);
        sleep(1);
    }
}

/*
 * fifo_read_example.c
 * 使用路径 "/tmp/testfifo" 打开 FIFO 文件
 * 即使两个进程不是父子/兄弟关系，但是使用同样的 FIFO 文件路径也能获得同样的共享内存
 */
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <sys/stat.h>
#include<fcntl.h>

int main() {
    int fd = open("/tmp/testfifo", O_RDONLY);
    if (fd < 0) {
        printf("failed to create fifo: %s\n", strerror(errno));
        exit(1);
    }

    char msg[6];

    while (true) {
        read(fd, msg, 6);
        printf("%s\n", msg);
    }
}
```

PIPE 和 FIFO 的区别在于前者只能通过文件描述符共享，后者可以通过文件路径共享，因此前者只适用于亲缘进程之间，后者适用于任何进程之间。  
Message Queue 和 FIFO 相似，又稍有不同：
- 二者都以文件路径作为共享的标志，但是 Message Queue 在文件路径之上再加了一个 project_id，也就是说使用 Message Queue 时，必须文件路径和 project_id 都相同才能获得同一个共享队列  
- FIFO 以文件的形式存在，但是 Message Queue 仍然只是内存 Buffer。Message Queue 只是以文件路径的 node 信息来生成队列的独特 ID，它自己不是文件，不创建文件，不读写文件，只是要求文件路径已经存在  
- Message Queue 里面的消息不再是以 byte 为单位来读写了，而是以一个打包的数据格式来读写。数据格式由程序自己定义，但是数据包中的前 8 个字节会被解释为 long 的消息类型，而且发送和接受时的数据格式大小必须一致
- 使用 Message Queue 接受消息时虽然也是先进先出的，可以按消息的类型来筛选

```c
// msg_write.c
#include <sys/msg.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <stdio.h>
#include <stdlib.h>
#include <zconf.h>
#include <cerrno>
#include <cstring>

struct msg {
    long mtype;
    char mdata[6];
};

int main() {
    key_t key;

    // 使用 / 路径和 ‘A’ 生成 id
    if ((key = ftok("/", 'A')) <= 0) {
        printf("failed to get key: %s\n", strerror(errno));
        exit(1);
    } else {
        printf("ftkey: %d\n", key);
    }

    int msg_id = msgget(key, IPC_CREAT | 0666);
    if (msg_id < 0) {
        printf("failed to get message queue: %s\n", strerror(errno));
        exit(1);
    } else {
        printf("msg_id: %d\n", msg_id);
    }

#define count 6
    msg msg_array[count];
    char * word[count] = {"hello", "world", "happy", "codes", "great", "minds"};
    for (int i = 0; i < count; i++) {
        msg_array[i].mtype = (i >> 1) + 1;
        memcpy(&(msg_array[i].mdata), word[i], 6 * sizeof(char));

        // 以 msg 数据格式为基本的传送单元
        if (msgsnd(msg_id, &msg_array[i], sizeof(msg), 0) < 0) {
            printf("failed to write msg: %s\n", strerror(errno));
            exit(1);
        }
    }
}

// msg_read.c
#include <sys/msg.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <stdio.h>
#include <stdlib.h>
#include <zconf.h>
#include <cerrno>
#include <cstring>

struct msg {
    long mtype;
    char mdata[6];
};

int main() {
    key_t key;
    // 使用 / 路径和 ‘A’ 生成 id
    if ((key = ftok("/", 'A')) <= 0) {
        printf("failed to get key: %s\n", strerror(errno));
        exit(1);
    } else {
        printf("ftkey: %d\n", key);
    }

    int msg_id = msgget(key, IPC_CREAT | 0666);
    if (msg_id < 0) {
        printf("failed to get message queue: %s\n", strerror(errno));
        exit(1);
    } else {
        printf("msg_id: %d\n", msg_id);
    }

    msg m;
    while (true) {
        // 同样以 msg 为基本的接受单元，筛选消息类型为 3 的数据包
        if (msgrcv(msg_id, &m, sizeof(msg), 3, 0) < 0) {
            printf("failed to receive msg: %s\n", strerror(errno));
            exit(1);
        }
        printf("%s\n", m.mdata);
    }
}
```

### 4.4 mmap 和 shm

### 4.5 waitpid

## 五、总结
